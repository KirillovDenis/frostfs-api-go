// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: object/types.proto

package object

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	refs "github.com/nspcc-dev/neofs-api-go/refs"
	service "github.com/nspcc-dev/neofs-api-go/service"
	storagegroup "github.com/nspcc-dev/neofs-api-go/storagegroup"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Link_Type int32

const (
	Link_Unknown Link_Type = 0
	// Parent object created during object transformation
	Link_Parent Link_Type = 1
	// Previous object in the linked list created during object transformation
	Link_Previous Link_Type = 2
	// Next object in the linked list created during object transformation
	Link_Next Link_Type = 3
	// Child object created during object transformation
	Link_Child Link_Type = 4
	// Object that included into this storage group
	Link_StorageGroup Link_Type = 5
)

var Link_Type_name = map[int32]string{
	0: "Unknown",
	1: "Parent",
	2: "Previous",
	3: "Next",
	4: "Child",
	5: "StorageGroup",
}

var Link_Type_value = map[string]int32{
	"Unknown":      0,
	"Parent":       1,
	"Previous":     2,
	"Next":         3,
	"Child":        4,
	"StorageGroup": 5,
}

func (x Link_Type) String() string {
	return proto.EnumName(Link_Type_name, int32(x))
}

func (Link_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{7, 0}
}

type Transform_Type int32

const (
	Transform_Unknown Transform_Type = 0
	// Split sets when object created after payload split
	Transform_Split Transform_Type = 1
	// Sign sets when object created after re-signing (doesn't used)
	Transform_Sign Transform_Type = 2
	// Mould sets when object created after filling missing headers in the object
	Transform_Mould Transform_Type = 3
)

var Transform_Type_name = map[int32]string{
	0: "Unknown",
	1: "Split",
	2: "Sign",
	3: "Mould",
}

var Transform_Type_value = map[string]int32{
	"Unknown": 0,
	"Split":   1,
	"Sign":    2,
	"Mould":   3,
}

func (x Transform_Type) String() string {
	return proto.EnumName(Transform_Type_name, int32(x))
}

func (Transform_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{8, 0}
}

type Range struct {
	// Offset of the data range
	Offset uint64 `protobuf:"varint,1,opt,name=Offset,proto3" json:"Offset,omitempty"`
	// Length of the data range
	Length               uint64   `protobuf:"varint,2,opt,name=Length,proto3" json:"Length,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Range) Reset()         { *m = Range{} }
func (m *Range) String() string { return proto.CompactTextString(m) }
func (*Range) ProtoMessage()    {}
func (*Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{0}
}
func (m *Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range.Merge(m, src)
}
func (m *Range) XXX_Size() int {
	return m.Size()
}
func (m *Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Range.DiscardUnknown(m)
}

var xxx_messageInfo_Range proto.InternalMessageInfo

func (m *Range) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *Range) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

type UserHeader struct {
	// Key of the user's header
	Key string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	// Value of the user's header
	Value                string   `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserHeader) Reset()         { *m = UserHeader{} }
func (m *UserHeader) String() string { return proto.CompactTextString(m) }
func (*UserHeader) ProtoMessage()    {}
func (*UserHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{1}
}
func (m *UserHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UserHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserHeader.Merge(m, src)
}
func (m *UserHeader) XXX_Size() int {
	return m.Size()
}
func (m *UserHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_UserHeader.DiscardUnknown(m)
}

var xxx_messageInfo_UserHeader proto.InternalMessageInfo

func (m *UserHeader) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *UserHeader) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type Header struct {
	// Types that are valid to be assigned to Value:
	//	*Header_Link
	//	*Header_Redirect
	//	*Header_UserHeader
	//	*Header_Transform
	//	*Header_Tombstone
	//	*Header_Token
	//	*Header_HomoHash
	//	*Header_PayloadChecksum
	//	*Header_Integrity
	//	*Header_StorageGroup
	//	*Header_PublicKey
	Value                isHeader_Value `protobuf_oneof:"Value"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{2}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

type isHeader_Value interface {
	isHeader_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Header_Link struct {
	Link *Link `protobuf:"bytes,1,opt,name=Link,proto3,oneof" json:"Link,omitempty"`
}
type Header_Redirect struct {
	Redirect *refs.Address `protobuf:"bytes,2,opt,name=Redirect,proto3,oneof" json:"Redirect,omitempty"`
}
type Header_UserHeader struct {
	UserHeader *UserHeader `protobuf:"bytes,3,opt,name=UserHeader,proto3,oneof" json:"UserHeader,omitempty"`
}
type Header_Transform struct {
	Transform *Transform `protobuf:"bytes,4,opt,name=Transform,proto3,oneof" json:"Transform,omitempty"`
}
type Header_Tombstone struct {
	Tombstone *Tombstone `protobuf:"bytes,5,opt,name=Tombstone,proto3,oneof" json:"Tombstone,omitempty"`
}
type Header_Token struct {
	Token *service.Token `protobuf:"bytes,6,opt,name=Token,proto3,oneof" json:"Token,omitempty"`
}
type Header_HomoHash struct {
	HomoHash Hash `protobuf:"bytes,7,opt,name=HomoHash,proto3,oneof,customtype=Hash" json:"HomoHash,omitempty"`
}
type Header_PayloadChecksum struct {
	PayloadChecksum []byte `protobuf:"bytes,8,opt,name=PayloadChecksum,proto3,oneof" json:"PayloadChecksum,omitempty"`
}
type Header_Integrity struct {
	Integrity *IntegrityHeader `protobuf:"bytes,9,opt,name=Integrity,proto3,oneof" json:"Integrity,omitempty"`
}
type Header_StorageGroup struct {
	StorageGroup *storagegroup.StorageGroup `protobuf:"bytes,10,opt,name=StorageGroup,proto3,oneof" json:"StorageGroup,omitempty"`
}
type Header_PublicKey struct {
	PublicKey *PublicKey `protobuf:"bytes,11,opt,name=PublicKey,proto3,oneof" json:"PublicKey,omitempty"`
}

func (*Header_Link) isHeader_Value()            {}
func (*Header_Redirect) isHeader_Value()        {}
func (*Header_UserHeader) isHeader_Value()      {}
func (*Header_Transform) isHeader_Value()       {}
func (*Header_Tombstone) isHeader_Value()       {}
func (*Header_Token) isHeader_Value()           {}
func (*Header_HomoHash) isHeader_Value()        {}
func (*Header_PayloadChecksum) isHeader_Value() {}
func (*Header_Integrity) isHeader_Value()       {}
func (*Header_StorageGroup) isHeader_Value()    {}
func (*Header_PublicKey) isHeader_Value()       {}

func (m *Header) GetValue() isHeader_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Header) GetLink() *Link {
	if x, ok := m.GetValue().(*Header_Link); ok {
		return x.Link
	}
	return nil
}

func (m *Header) GetRedirect() *refs.Address {
	if x, ok := m.GetValue().(*Header_Redirect); ok {
		return x.Redirect
	}
	return nil
}

func (m *Header) GetUserHeader() *UserHeader {
	if x, ok := m.GetValue().(*Header_UserHeader); ok {
		return x.UserHeader
	}
	return nil
}

func (m *Header) GetTransform() *Transform {
	if x, ok := m.GetValue().(*Header_Transform); ok {
		return x.Transform
	}
	return nil
}

func (m *Header) GetTombstone() *Tombstone {
	if x, ok := m.GetValue().(*Header_Tombstone); ok {
		return x.Tombstone
	}
	return nil
}

func (m *Header) GetToken() *service.Token {
	if x, ok := m.GetValue().(*Header_Token); ok {
		return x.Token
	}
	return nil
}

func (m *Header) GetPayloadChecksum() []byte {
	if x, ok := m.GetValue().(*Header_PayloadChecksum); ok {
		return x.PayloadChecksum
	}
	return nil
}

func (m *Header) GetIntegrity() *IntegrityHeader {
	if x, ok := m.GetValue().(*Header_Integrity); ok {
		return x.Integrity
	}
	return nil
}

func (m *Header) GetStorageGroup() *storagegroup.StorageGroup {
	if x, ok := m.GetValue().(*Header_StorageGroup); ok {
		return x.StorageGroup
	}
	return nil
}

func (m *Header) GetPublicKey() *PublicKey {
	if x, ok := m.GetValue().(*Header_PublicKey); ok {
		return x.PublicKey
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Header) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Header_Link)(nil),
		(*Header_Redirect)(nil),
		(*Header_UserHeader)(nil),
		(*Header_Transform)(nil),
		(*Header_Tombstone)(nil),
		(*Header_Token)(nil),
		(*Header_HomoHash)(nil),
		(*Header_PayloadChecksum)(nil),
		(*Header_Integrity)(nil),
		(*Header_StorageGroup)(nil),
		(*Header_PublicKey)(nil),
	}
}

type Tombstone struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tombstone) Reset()         { *m = Tombstone{} }
func (m *Tombstone) String() string { return proto.CompactTextString(m) }
func (*Tombstone) ProtoMessage()    {}
func (*Tombstone) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{3}
}
func (m *Tombstone) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tombstone) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Tombstone) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tombstone.Merge(m, src)
}
func (m *Tombstone) XXX_Size() int {
	return m.Size()
}
func (m *Tombstone) XXX_DiscardUnknown() {
	xxx_messageInfo_Tombstone.DiscardUnknown(m)
}

var xxx_messageInfo_Tombstone proto.InternalMessageInfo

type SystemHeader struct {
	// Version of the object structure
	Version uint64 `protobuf:"varint,1,opt,name=Version,proto3" json:"Version,omitempty"`
	// PayloadLength is an object payload length
	PayloadLength uint64 `protobuf:"varint,2,opt,name=PayloadLength,proto3" json:"PayloadLength,omitempty"`
	// ID is an object identifier, is a valid UUIDv4
	ID ID `protobuf:"bytes,3,opt,name=ID,proto3,customtype=ID" json:"ID"`
	// OwnerID is a wallet address
	OwnerID OwnerID `protobuf:"bytes,4,opt,name=OwnerID,proto3,customtype=OwnerID" json:"OwnerID"`
	// CID is a SHA256 hash of the container structure (container identifier)
	CID CID `protobuf:"bytes,5,opt,name=CID,proto3,customtype=CID" json:"CID"`
	// CreatedAt is a timestamp of object creation
	CreatedAt            CreationPoint `protobuf:"bytes,6,opt,name=CreatedAt,proto3" json:"CreatedAt"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SystemHeader) Reset()         { *m = SystemHeader{} }
func (m *SystemHeader) String() string { return proto.CompactTextString(m) }
func (*SystemHeader) ProtoMessage()    {}
func (*SystemHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{4}
}
func (m *SystemHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SystemHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SystemHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemHeader.Merge(m, src)
}
func (m *SystemHeader) XXX_Size() int {
	return m.Size()
}
func (m *SystemHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemHeader.DiscardUnknown(m)
}

var xxx_messageInfo_SystemHeader proto.InternalMessageInfo

func (m *SystemHeader) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *SystemHeader) GetPayloadLength() uint64 {
	if m != nil {
		return m.PayloadLength
	}
	return 0
}

func (m *SystemHeader) GetCreatedAt() CreationPoint {
	if m != nil {
		return m.CreatedAt
	}
	return CreationPoint{}
}

type CreationPoint struct {
	// UnixTime is a date of creation in unixtime format
	UnixTime int64 `protobuf:"varint,1,opt,name=UnixTime,proto3" json:"UnixTime,omitempty"`
	// Epoch is a date of creation in NeoFS epochs
	Epoch                uint64   `protobuf:"varint,2,opt,name=Epoch,proto3" json:"Epoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreationPoint) Reset()      { *m = CreationPoint{} }
func (*CreationPoint) ProtoMessage() {}
func (*CreationPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{5}
}
func (m *CreationPoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreationPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreationPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreationPoint.Merge(m, src)
}
func (m *CreationPoint) XXX_Size() int {
	return m.Size()
}
func (m *CreationPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_CreationPoint.DiscardUnknown(m)
}

var xxx_messageInfo_CreationPoint proto.InternalMessageInfo

func (m *CreationPoint) GetUnixTime() int64 {
	if m != nil {
		return m.UnixTime
	}
	return 0
}

func (m *CreationPoint) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

type IntegrityHeader struct {
	// HeadersChecksum is a checksum of all above headers in the object
	HeadersChecksum []byte `protobuf:"bytes,1,opt,name=HeadersChecksum,proto3" json:"HeadersChecksum,omitempty"`
	// ChecksumSignature is an user's signature of checksum to verify if it is correct
	ChecksumSignature    []byte   `protobuf:"bytes,2,opt,name=ChecksumSignature,proto3" json:"ChecksumSignature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IntegrityHeader) Reset()         { *m = IntegrityHeader{} }
func (m *IntegrityHeader) String() string { return proto.CompactTextString(m) }
func (*IntegrityHeader) ProtoMessage()    {}
func (*IntegrityHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{6}
}
func (m *IntegrityHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntegrityHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IntegrityHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntegrityHeader.Merge(m, src)
}
func (m *IntegrityHeader) XXX_Size() int {
	return m.Size()
}
func (m *IntegrityHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_IntegrityHeader.DiscardUnknown(m)
}

var xxx_messageInfo_IntegrityHeader proto.InternalMessageInfo

func (m *IntegrityHeader) GetHeadersChecksum() []byte {
	if m != nil {
		return m.HeadersChecksum
	}
	return nil
}

func (m *IntegrityHeader) GetChecksumSignature() []byte {
	if m != nil {
		return m.ChecksumSignature
	}
	return nil
}

type Link struct {
	// Type of link
	Type Link_Type `protobuf:"varint,1,opt,name=type,proto3,enum=object.Link_Type" json:"type,omitempty"`
	// ID is an object identifier, is a valid UUIDv4
	ID                   ID       `protobuf:"bytes,2,opt,name=ID,proto3,customtype=ID" json:"ID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Link) Reset()         { *m = Link{} }
func (m *Link) String() string { return proto.CompactTextString(m) }
func (*Link) ProtoMessage()    {}
func (*Link) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{7}
}
func (m *Link) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Link) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Link) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Link.Merge(m, src)
}
func (m *Link) XXX_Size() int {
	return m.Size()
}
func (m *Link) XXX_DiscardUnknown() {
	xxx_messageInfo_Link.DiscardUnknown(m)
}

var xxx_messageInfo_Link proto.InternalMessageInfo

func (m *Link) GetType() Link_Type {
	if m != nil {
		return m.Type
	}
	return Link_Unknown
}

type Transform struct {
	// Type of object transformation
	Type                 Transform_Type `protobuf:"varint,1,opt,name=type,proto3,enum=object.Transform_Type" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Transform) Reset()         { *m = Transform{} }
func (m *Transform) String() string { return proto.CompactTextString(m) }
func (*Transform) ProtoMessage()    {}
func (*Transform) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{8}
}
func (m *Transform) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transform) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Transform) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transform.Merge(m, src)
}
func (m *Transform) XXX_Size() int {
	return m.Size()
}
func (m *Transform) XXX_DiscardUnknown() {
	xxx_messageInfo_Transform.DiscardUnknown(m)
}

var xxx_messageInfo_Transform proto.InternalMessageInfo

func (m *Transform) GetType() Transform_Type {
	if m != nil {
		return m.Type
	}
	return Transform_Unknown
}

type Object struct {
	// SystemHeader describes system header
	SystemHeader SystemHeader `protobuf:"bytes,1,opt,name=SystemHeader,proto3" json:"SystemHeader"`
	// Headers describes a set of an extended headers
	Headers []Header `protobuf:"bytes,2,rep,name=Headers,proto3" json:"Headers"`
	// Payload is an object's payload
	Payload              []byte   `protobuf:"bytes,3,opt,name=Payload,proto3" json:"Payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Object) Reset()         { *m = Object{} }
func (m *Object) String() string { return proto.CompactTextString(m) }
func (*Object) ProtoMessage()    {}
func (*Object) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{9}
}
func (m *Object) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Object) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Object) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Object.Merge(m, src)
}
func (m *Object) XXX_Size() int {
	return m.Size()
}
func (m *Object) XXX_DiscardUnknown() {
	xxx_messageInfo_Object.DiscardUnknown(m)
}

var xxx_messageInfo_Object proto.InternalMessageInfo

func (m *Object) GetSystemHeader() SystemHeader {
	if m != nil {
		return m.SystemHeader
	}
	return SystemHeader{}
}

func (m *Object) GetHeaders() []Header {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *Object) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type PublicKey struct {
	// Value contains marshaled ecdsa public key
	Value                []byte   `protobuf:"bytes,1,opt,name=Value,proto3" json:"Value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PublicKey) Reset()         { *m = PublicKey{} }
func (m *PublicKey) String() string { return proto.CompactTextString(m) }
func (*PublicKey) ProtoMessage()    {}
func (*PublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_02021a1d39b1aee0, []int{10}
}
func (m *PublicKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicKey.Merge(m, src)
}
func (m *PublicKey) XXX_Size() int {
	return m.Size()
}
func (m *PublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_PublicKey proto.InternalMessageInfo

func (m *PublicKey) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func init() {
	proto.RegisterEnum("object.Link_Type", Link_Type_name, Link_Type_value)
	proto.RegisterEnum("object.Transform_Type", Transform_Type_name, Transform_Type_value)
	proto.RegisterType((*Range)(nil), "object.Range")
	proto.RegisterType((*UserHeader)(nil), "object.UserHeader")
	proto.RegisterType((*Header)(nil), "object.Header")
	proto.RegisterType((*Tombstone)(nil), "object.Tombstone")
	proto.RegisterType((*SystemHeader)(nil), "object.SystemHeader")
	proto.RegisterType((*CreationPoint)(nil), "object.CreationPoint")
	proto.RegisterType((*IntegrityHeader)(nil), "object.IntegrityHeader")
	proto.RegisterType((*Link)(nil), "object.Link")
	proto.RegisterType((*Transform)(nil), "object.Transform")
	proto.RegisterType((*Object)(nil), "object.Object")
	proto.RegisterType((*PublicKey)(nil), "object.PublicKey")
}

func init() { proto.RegisterFile("object/types.proto", fileDescriptor_02021a1d39b1aee0) }

var fileDescriptor_02021a1d39b1aee0 = []byte{
	// 916 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x55, 0x4f, 0x8f, 0xdb, 0x44,
	0x14, 0xb7, 0x13, 0xe7, 0xdf, 0x8b, 0xb7, 0xeb, 0x8e, 0x96, 0x62, 0x45, 0x22, 0xbb, 0x58, 0x50,
	0x2d, 0x85, 0x75, 0x44, 0x8b, 0x54, 0xc1, 0x01, 0xb1, 0xd9, 0x40, 0x1d, 0x51, 0xba, 0x61, 0x92,
	0xed, 0x81, 0x9b, 0x93, 0x4c, 0x1c, 0xb3, 0xc9, 0x4c, 0x34, 0x33, 0xd9, 0x36, 0x5f, 0x83, 0x53,
	0x6f, 0x70, 0x44, 0x7c, 0x92, 0x1e, 0x39, 0xa2, 0x1e, 0x56, 0x68, 0xf9, 0x00, 0x7c, 0x85, 0x6a,
	0xc6, 0x76, 0x62, 0x6f, 0x7b, 0x89, 0xe6, 0xbd, 0xdf, 0xef, 0x37, 0x7e, 0xf3, 0xde, 0x6f, 0x26,
	0x80, 0xd8, 0xf8, 0x57, 0x32, 0x91, 0x1d, 0xb9, 0x59, 0x11, 0xe1, 0xaf, 0x38, 0x93, 0x0c, 0x55,
	0x93, 0x5c, 0xcb, 0xe1, 0x64, 0x26, 0xf2, 0x48, 0xeb, 0x40, 0x10, 0x7e, 0x15, 0x4f, 0x48, 0xe7,
	0x8a, 0xf0, 0x78, 0xb6, 0x49, 0xb3, 0xae, 0x90, 0x8c, 0x87, 0x11, 0x89, 0x38, 0x5b, 0xaf, 0x0a,
	0xfc, 0x93, 0x28, 0x96, 0xf3, 0xf5, 0xd8, 0x9f, 0xb0, 0x65, 0x27, 0x62, 0x11, 0xeb, 0xe8, 0xf4,
	0x78, 0x3d, 0xd3, 0x91, 0x0e, 0xf4, 0x2a, 0xa1, 0x7b, 0x8f, 0xa1, 0x82, 0x43, 0x1a, 0x11, 0x74,
	0x0f, 0xaa, 0xe7, 0xb3, 0x99, 0x20, 0xd2, 0x35, 0x8f, 0xcc, 0x63, 0x0b, 0xa7, 0x91, 0xca, 0x3f,
	0x25, 0x34, 0x92, 0x73, 0xb7, 0x94, 0xe4, 0x93, 0xc8, 0xfb, 0x0a, 0xe0, 0x42, 0x10, 0x1e, 0x90,
	0x70, 0x4a, 0x38, 0x72, 0xa0, 0xfc, 0x23, 0xd9, 0x68, 0x69, 0x03, 0xab, 0x25, 0x3a, 0x80, 0xca,
	0xf3, 0x70, 0xb1, 0x26, 0x5a, 0xd6, 0xc0, 0x49, 0xe0, 0xfd, 0x69, 0x41, 0x35, 0x95, 0x78, 0x60,
	0x3d, 0x8d, 0xe9, 0xa5, 0xd6, 0x34, 0x1f, 0xda, 0x7e, 0xd2, 0x01, 0x5f, 0xe5, 0x02, 0x03, 0x6b,
	0x0c, 0x7d, 0x0e, 0x75, 0x4c, 0xa6, 0x31, 0x27, 0x13, 0xa9, 0xf7, 0x69, 0x3e, 0xdc, 0xf3, 0x55,
	0x87, 0xfc, 0xd3, 0xe9, 0x94, 0x13, 0x21, 0x02, 0x03, 0x6f, 0x09, 0xa8, 0x50, 0x91, 0x5b, 0xd6,
	0x74, 0x94, 0x6d, 0xbb, 0x43, 0x02, 0x03, 0xe7, 0x2b, 0xff, 0x12, 0x1a, 0x23, 0x1e, 0x52, 0x31,
	0x63, 0x7c, 0xe9, 0x5a, 0x5a, 0x74, 0x37, 0x13, 0x6d, 0x81, 0xc0, 0xc0, 0x3b, 0x96, 0x96, 0xb0,
	0xe5, 0x58, 0x48, 0x46, 0x89, 0x5b, 0xb9, 0x25, 0xc9, 0x00, 0x2d, 0xc9, 0x02, 0x74, 0x1f, 0x2a,
	0x23, 0x76, 0x49, 0xa8, 0x5b, 0xd5, 0xf4, 0x3b, 0x7e, 0x3a, 0x55, 0x5f, 0x67, 0x03, 0x03, 0x27,
	0x30, 0xba, 0x0f, 0xf5, 0x80, 0x2d, 0x59, 0x10, 0x8a, 0xb9, 0x5b, 0x3b, 0x32, 0x8f, 0xed, 0x6e,
	0xfd, 0xcd, 0xf5, 0xa1, 0xa5, 0x62, 0x75, 0xd6, 0x0c, 0x43, 0x0f, 0x60, 0x7f, 0x10, 0x6e, 0x16,
	0x2c, 0x9c, 0x9e, 0xcd, 0xc9, 0xe4, 0x52, 0xac, 0x97, 0x6e, 0x5d, 0xd1, 0x03, 0x03, 0xdf, 0x06,
	0xd0, 0x63, 0x68, 0xf4, 0xa9, 0x24, 0x11, 0x8f, 0xe5, 0xc6, 0x6d, 0xe8, 0xef, 0x7f, 0x98, 0x95,
	0xbb, 0x05, 0xb6, 0xbd, 0xd9, 0x71, 0xd1, 0x77, 0x60, 0x0f, 0x13, 0x9b, 0x3d, 0x51, 0x36, 0x73,
	0x41, 0x6b, 0x5b, 0x7e, 0xde, 0x7b, 0x7e, 0x9e, 0x11, 0x18, 0xb8, 0xa0, 0x50, 0x9d, 0x1a, 0xac,
	0xc7, 0x8b, 0x78, 0xa2, 0xcc, 0xd1, 0x2c, 0x76, 0x6a, 0x0b, 0xa8, 0x8f, 0x6e, 0x83, 0x6e, 0x2d,
	0xf5, 0x8d, 0xd7, 0xcc, 0x75, 0xd9, 0xfb, 0xdf, 0x04, 0x7b, 0xb8, 0x11, 0x92, 0x2c, 0xd3, 0xb1,
	0xb9, 0x50, 0x7b, 0x4e, 0xb8, 0x88, 0x19, 0x4d, 0xfd, 0x9a, 0x85, 0xe8, 0x13, 0xd8, 0x4b, 0x3b,
	0x50, 0xf0, 0x6d, 0x31, 0x89, 0x5a, 0x50, 0xea, 0xf7, 0xb4, 0x49, 0xec, 0x2e, 0xbc, 0xbe, 0x3e,
	0x34, 0xde, 0x5c, 0x1f, 0x96, 0xfa, 0x3d, 0x5c, 0xea, 0xf7, 0xd0, 0x67, 0x50, 0x3b, 0x7f, 0x41,
	0x09, 0xef, 0xf7, 0xb4, 0x21, 0xec, 0xee, 0x7e, 0x4a, 0xc8, 0xd2, 0x38, 0x5b, 0xa0, 0x8f, 0xa0,
	0x7c, 0xd6, 0xef, 0x69, 0x13, 0xd8, 0xdd, 0x66, 0x4a, 0x53, 0x29, 0xac, 0x7e, 0xd0, 0xd7, 0xd0,
	0x38, 0xe3, 0x24, 0x94, 0x64, 0x7a, 0x2a, 0xd3, 0xd1, 0x7f, 0x90, 0x9d, 0x5f, 0x03, 0x31, 0xa3,
	0x03, 0x16, 0x53, 0xd9, 0xb5, 0x94, 0x16, 0xef, 0xd8, 0xde, 0x13, 0xd8, 0x2b, 0x30, 0x50, 0x0b,
	0xea, 0x17, 0x34, 0x7e, 0x39, 0x8a, 0x97, 0x44, 0x1f, 0xb9, 0x8c, 0xb7, 0xb1, 0xba, 0x6c, 0xdf,
	0xaf, 0xd8, 0x24, 0x3b, 0x6b, 0x12, 0x7c, 0x63, 0xbd, 0xfa, 0xe3, 0xd0, 0xf0, 0x62, 0xd8, 0xbf,
	0x35, 0x65, 0x74, 0x0c, 0xfb, 0xc9, 0x4a, 0x6c, 0xdd, 0xa3, 0x76, 0xb4, 0xf1, 0xed, 0x34, 0xfa,
	0x02, 0xee, 0x66, 0xeb, 0x61, 0x1c, 0xd1, 0x50, 0xae, 0x79, 0x72, 0xa3, 0x6d, 0xfc, 0x2e, 0xe0,
	0xfd, 0x6e, 0x26, 0x77, 0x1a, 0x7d, 0x0a, 0x96, 0x7a, 0x93, 0xf4, 0xae, 0x77, 0x76, 0x23, 0x57,
	0x98, 0x3f, 0xda, 0xac, 0x08, 0xd6, 0x70, 0x3a, 0x84, 0xd2, 0xfb, 0x86, 0xe0, 0x8d, 0xc0, 0x52,
	0x4c, 0xd4, 0x84, 0xda, 0x05, 0xbd, 0xa4, 0xec, 0x05, 0x75, 0x0c, 0x04, 0x50, 0x1d, 0x84, 0x9c,
	0x50, 0xe9, 0x98, 0xc8, 0x86, 0xfa, 0x80, 0x93, 0xab, 0x98, 0xad, 0x85, 0x53, 0x42, 0x75, 0xb0,
	0x9e, 0x91, 0x97, 0xd2, 0x29, 0xa3, 0x06, 0x54, 0xce, 0xe6, 0xf1, 0x62, 0xea, 0x58, 0xc8, 0x29,
	0x1a, 0xd8, 0xa9, 0x78, 0x8b, 0xdc, 0x6d, 0x47, 0x0f, 0x0a, 0x55, 0xde, 0x7b, 0xe7, 0xd6, 0xe7,
	0x4a, 0xf5, 0x1e, 0xbd, 0xaf, 0x9c, 0x06, 0x54, 0x86, 0xab, 0x45, 0xac, 0xaa, 0xa9, 0x83, 0xa5,
	0xfa, 0xe0, 0x94, 0x54, 0xf2, 0x27, 0xb6, 0x5e, 0x4c, 0x9d, 0xb2, 0xf7, 0x9b, 0x09, 0xd5, 0x73,
	0xbd, 0x29, 0xfa, 0xb6, 0xe8, 0xdf, 0xf4, 0xd5, 0x3b, 0xc8, 0xbe, 0x99, 0xc7, 0x52, 0x2f, 0x14,
	0xfd, 0xee, 0x43, 0x2d, 0x9d, 0x8d, 0x5b, 0x3a, 0x2a, 0xeb, 0x27, 0x24, 0x95, 0x16, 0x44, 0x19,
	0x49, 0xdd, 0x8f, 0xd4, 0xf0, 0x89, 0xc9, 0x71, 0x16, 0x7a, 0x1f, 0xe7, 0xee, 0xe4, 0xee, 0x95,
	0x4e, 0xe6, 0x9f, 0x04, 0xdd, 0x9f, 0x5f, 0xdf, 0xb4, 0xcd, 0xbf, 0x6f, 0xda, 0xe6, 0x3f, 0x37,
	0x6d, 0xf3, 0xdf, 0x9b, 0xb6, 0xf9, 0xea, 0xbf, 0xb6, 0xf1, 0xcb, 0x71, 0xee, 0x9f, 0x85, 0x8a,
	0xd5, 0x64, 0x72, 0x32, 0x25, 0x57, 0x1d, 0x4a, 0xd8, 0x4c, 0x9c, 0x84, 0xab, 0xf8, 0x24, 0x62,
	0x9d, 0xa4, 0xa4, 0xbf, 0x4a, 0xce, 0x33, 0xc2, 0x7e, 0x18, 0xfa, 0xa7, 0x83, 0xbe, 0x9f, 0x9c,
	0x7f, 0x5c, 0xd5, 0x7f, 0x37, 0x8f, 0xde, 0x06, 0x00, 0x00, 0xff, 0xff, 0x4e, 0xcb, 0xd2, 0xde,
	0xfd, 0x06, 0x00, 0x00,
}

func (m *Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Length != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x10
	}
	if m.Offset != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Header_Link) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_Link) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Link != nil {
		{
			size, err := m.Link.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Header_Redirect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_Redirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Redirect != nil {
		{
			size, err := m.Redirect.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Header_UserHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_UserHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UserHeader != nil {
		{
			size, err := m.UserHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Header_Transform) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_Transform) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Transform != nil {
		{
			size, err := m.Transform.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Header_Tombstone) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_Tombstone) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Tombstone != nil {
		{
			size, err := m.Tombstone.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Header_Token) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_Token) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Header_HomoHash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_HomoHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	{
		size := m.HomoHash.Size()
		i -= size
		if _, err := m.HomoHash.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	return len(dAtA) - i, nil
}
func (m *Header_PayloadChecksum) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_PayloadChecksum) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PayloadChecksum != nil {
		i -= len(m.PayloadChecksum)
		copy(dAtA[i:], m.PayloadChecksum)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PayloadChecksum)))
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Header_Integrity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_Integrity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Integrity != nil {
		{
			size, err := m.Integrity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Header_StorageGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_StorageGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StorageGroup != nil {
		{
			size, err := m.StorageGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Header_PublicKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_PublicKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PublicKey != nil {
		{
			size, err := m.PublicKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Tombstone) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tombstone) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tombstone) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SystemHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.CID.Size()
		i -= size
		if _, err := m.CID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.OwnerID.Size()
		i -= size
		if _, err := m.OwnerID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.ID.Size()
		i -= size
		if _, err := m.ID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.PayloadLength != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PayloadLength))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreationPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreationPoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreationPoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Epoch != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x10
	}
	if m.UnixTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UnixTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IntegrityHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntegrityHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IntegrityHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ChecksumSignature) > 0 {
		i -= len(m.ChecksumSignature)
		copy(dAtA[i:], m.ChecksumSignature)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ChecksumSignature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.HeadersChecksum) > 0 {
		i -= len(m.HeadersChecksum)
		copy(dAtA[i:], m.HeadersChecksum)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HeadersChecksum)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Link) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Link) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Link) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size := m.ID.Size()
		i -= size
		if _, err := m.ID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Transform) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transform) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transform) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Object) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Object) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Object) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.SystemHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PublicKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublicKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Offset != 0 {
		n += 1 + sovTypes(uint64(m.Offset))
	}
	if m.Length != 0 {
		n += 1 + sovTypes(uint64(m.Length))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Header_Link) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Link != nil {
		l = m.Link.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Header_Redirect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Redirect != nil {
		l = m.Redirect.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Header_UserHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserHeader != nil {
		l = m.UserHeader.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Header_Transform) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Transform != nil {
		l = m.Transform.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Header_Tombstone) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tombstone != nil {
		l = m.Tombstone.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Header_Token) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Header_HomoHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.HomoHash.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *Header_PayloadChecksum) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PayloadChecksum != nil {
		l = len(m.PayloadChecksum)
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Header_Integrity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Integrity != nil {
		l = m.Integrity.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Header_StorageGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageGroup != nil {
		l = m.StorageGroup.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Header_PublicKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublicKey != nil {
		l = m.PublicKey.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Tombstone) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SystemHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovTypes(uint64(m.Version))
	}
	if m.PayloadLength != 0 {
		n += 1 + sovTypes(uint64(m.PayloadLength))
	}
	l = m.ID.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.OwnerID.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.CID.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.CreatedAt.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreationPoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnixTime != 0 {
		n += 1 + sovTypes(uint64(m.UnixTime))
	}
	if m.Epoch != 0 {
		n += 1 + sovTypes(uint64(m.Epoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IntegrityHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HeadersChecksum)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ChecksumSignature)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Link) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	l = m.ID.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Transform) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Object) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SystemHeader.Size()
	n += 1 + l + sovTypes(uint64(l))
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PublicKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Link{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Header_Link{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redirect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &refs.Address{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Header_Redirect{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UserHeader{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Header_UserHeader{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transform", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Transform{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Header_Transform{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tombstone", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Tombstone{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Header_Tombstone{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &service.Token{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Header_Token{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomoHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var vv Hash
			v := &vv
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Header_HomoHash{*v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadChecksum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Value = &Header_PayloadChecksum{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Integrity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IntegrityHeader{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Header_Integrity{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &storagegroup.StorageGroup{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Header_StorageGroup{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PublicKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Header_PublicKey{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tombstone) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tombstone: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tombstone: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadLength", wireType)
			}
			m.PayloadLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OwnerID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreationPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreationPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreationPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnixTime", wireType)
			}
			m.UnixTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnixTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntegrityHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntegrityHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntegrityHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadersChecksum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadersChecksum = append(m.HeadersChecksum[:0], dAtA[iNdEx:postIndex]...)
			if m.HeadersChecksum == nil {
				m.HeadersChecksum = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChecksumSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChecksumSignature = append(m.ChecksumSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.ChecksumSignature == nil {
				m.ChecksumSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Link) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Link: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Link: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Link_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transform) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transform: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transform: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Transform_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Object) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Object: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Object: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SystemHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, Header{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
